subinclude("///proto//build_defs:proto")

original_proto_library = proto_library

def proto_library(
        name:str, srcs:list, deps:list=[], visibility:list=[], labels:list&features&tags=[],
        protoc_flags:list=[], languages:list|dict={}, test_only:bool&testonly=False,
        root_dir:str='',
):
    """Extends the proto library with our customisation"""
    if isinstance(languages, dict):
        languages['go'] = go_proto_language()
    # elif isinstance(languages, list):
    #     languages.append(go_proto_language())
    return original_proto_library(
        name = name,
        srcs = srcs,
        deps = deps,
        visibility = visibility,
        labels = labels,
        languages = languages,
        test_only = test_only,
        root_dir = root_dir,
        protoc_flags = protoc_flags,
    )

def go_proto_language():
    return proto_language(
        language = "go",
        build_def = go_proto_library,
        additional_provides = { "go_src": "go_srcs", "modinfo": "go_modinfo" },
    )

def go_proto_library(name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
                     test_only:bool&testonly=False, root_dir:str='', protoc_flags:list=[], additional_context:dict=None):
    if additional_context:
        fail("additional_context is not used in this rule")
    deps += [
        CONFIG.GO_PROTO.PROTO_DEP,
    ]
    protoc = protoc_rule(
        name = name,
        srcs = srcs,
        language = "go",
        tools = {
            "go": [CONFIG.GO_PROTO.PLUGIN],
        },
        protoc_flags = protoc_flags,
        plugin_flags = [
            # Go plugin.
            '--plugin=protoc-gen-go="`which $TOOLS_GO`"',
            '--go_out="$OUT_DIR"',
            '--go_opt=paths=source_relative',
            # Gen validate plugin.
        ],
        labels = labels + _go_mapping_labels(srcs, root_dir),
        test_only = test_only,
        root_dir = root_dir,
        deps = deps,
        visibility = visibility,
        pre_build = _go_path_mapping(),
    )
    return go_library(
        name = f"_{name}#go",
        srcs = [protoc],
        deps = deps,
        test_only = test_only,
        labels = labels,
        visibility = visibility,
        import_path = _import_path(root_dir)
    )

def grpc_library(
        name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
        protoc_flags:list=[], languages:list|dict={}, test_only:bool&testonly=False,
        root_dir:str='',
):
    """Extends the grpc library with our customization"""
    if isinstance(languages, dict):
        languages['go'] = go_grpc_language()
    # elif isinstance(languages, list):
    #     languages.append(go_grpc_language())
    filegroup(
        name = f'{name}#protos',
        srcs = srcs,
        visibility = visibility,
        deps = deps,
    )
    return original_proto_library(
        name = name,
        srcs = srcs,
        deps = deps,
        visibility = visibility,
        labels = labels,
        languages = languages,
        test_only = test_only,
        root_dir = root_dir,
        protoc_flags = protoc_flags,
    )

def go_grpc_language():
    return proto_language(
        language = "go",
        build_def = go_grpc_library,
        additional_provides = {"go_src": "go_srcs", "modinfo": "go_modinfo"},
    )


def go_grpc_library(name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
                    test_only:bool&testonly=False, root_dir:str='', protoc_flags:list=[], additional_context:dict=None):
    """Defines a rule for a go grpc library."""
    if additional_context:
        fail("additional_context is not used in this rule")
    deps += [
        CONFIG.GO_PROTO.PROTO_DEP,
        CONFIG.GO_PROTO.GRPC_DEP,
    ]
    protoc = protoc_rule(
        name = name,
        srcs = srcs,
        language = "go",
        tools = {
            "go": [CONFIG.GO_PROTO.PLUGIN],
            "grpc_go": [CONFIG.GO_PROTO.GRPC_PLUGIN],
        },
        protoc_flags = protoc_flags,
        plugin_flags = [
            # Go plugin.
            '--plugin=protoc-gen-go="`which $TOOLS_GO`"',
            '--go_out="$OUT_DIR"',
            '--go_opt=paths=source_relative',
            # gRPC plugin.
            '--go-grpc_out="$OUT_DIR"',
            '--plugin=protoc-gen-go-grpc="`which $TOOLS_GRPC_GO`"',
            '--go-grpc_opt=paths=source_relative,require_unimplemented_servers=false',
            # Gen validate plugin.
        ],
        labels = labels + _go_mapping_labels(srcs, root_dir),
        test_only = test_only,
        root_dir = root_dir,
        deps = deps,
        visibility = visibility,
        pre_build = _go_path_mapping(),
    )
    return go_library(
        name = f"_{name}#go",
        srcs = [protoc],
        deps = deps,
        test_only = test_only,
        labels = labels,
        visibility = visibility,
        import_path = _import_path(root_dir)
    )


def grpc_gateway_library(
        name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
        protoc_flags:list=[], languages:list|dict={}, test_only:bool&testonly=False,
        root_dir:str='',
):
    if isinstance(languages, dict):
        languages['go'] = go_grpc_gateway_language()
    elif isinstance(languages, list):
        languages.append(go_grpc_gateway_language())

    filegroup(
        name = f'{name}#protos',
        srcs = srcs,
        visibility = visibility,
        deps = deps,
    )
    return original_proto_library(
        name = name,
        srcs = srcs,
        deps = deps,
        visibility = visibility,
        labels = labels,
        languages = languages,
        test_only = test_only,
        root_dir = root_dir,
        protoc_flags = protoc_flags,
    )


def go_grpc_gateway_language():
    return proto_language(
        language = "go",
        build_def = go_grpc_gateway_library,   
        additional_provides = {"go_src": "go_srcs", "modinfo": "go_modinfo"},
    )


def go_grpc_gateway_library(name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
                            test_only:bool&testonly=False, root_dir:str='', protoc_flags:list=[], additional_context:dict=None):
    """Defines a rule for a go grpc gateway library"""
    if additional_context:
        fail("additional_context is not used in this rule")
    deps += [
        CONFIG.GO_PROTO.PROTO_DEP,
        CONFIG.GO_PROTO.GRPC_DEP,
        CONFIG.GRPC_GATEWAY_PLUGIN,
        CONFIG.GRPC_GATEWAY_GO_DEP,
    ]
    protoc = protoc_rule(
        name = name,
        srcs = srcs,
        language = "go",
        tools = {
            "go": [CONFIG.GO_PROTO.PLUGIN],
            "grpc_go": [CONFIG.GO_PROTO.GRPC_PLUGIN],
            "grpc_gateway_go": [CONFIG.GRPC_GATEWAY_PLUGIN],
        },
        protoc_flags = protoc_flags,
        plugin_flags = [            
            # Go plugin.
            '--plugin=protoc-gen-go="`which $TOOLS_GO`"',
            '--go_out="$OUT_DIR"',
            '--go_opt=paths=source_relative',
            # gRPC plugin.
            '--go-grpc_out="$OUT_DIR"',
            '--plugin=protoc-gen-go-grpc="`which $TOOLS_GRPC_GO`"',
            '--go-grpc_opt=paths=source_relative,require_unimplemented_servers=false',
            # gRPC gateway plugin.
            '--plugin=protoc-gen-grpc-gateway="`which $TOOLS_GRPC_GATEWAY_GO`"',
            '--grpc-gateway_out="$OUT_DIR"',
            f'--grpc-gateway_opt=paths=source_relative',
            # Gen validate plugin.
        ],
        labels = labels + _go_mapping_labels(srcs, root_dir),
        test_only = test_only,
        root_dir = root_dir,
        deps = deps,
        visibility = visibility,
        pre_build = _go_path_mapping(),
    )
    return go_library(
        name = f"_{name}#go",
        srcs = [protoc],
        deps = deps,
        test_only = test_only,
        labels = labels,
        visibility = visibility,
        import_path = _import_path(root_dir),
    )


def grpc_gateway_standalone_library(        
        name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
        protoc_flags:list=[], languages:list|dict={}, test_only:bool&testonly=False,
        root_dir:str='', configuration:str=''
):
    configuration_rule = filegroup(
        name = f"_{name}_configuration",
        srcs = [configuration],
        visibility = visibility,
    )
    if isinstance(languages, dict):
        languages['go'] = go_grpc_gateway_standalone_language(configuration_rule)
    elif isinstance(languages, list):
        languages.append(go_grpc_gateway_standalone_language(configuration_rule))
    return original_proto_library(
        name = name,
        srcs = srcs,
        deps = deps + [configuration_rule],
        visibility = visibility,
        labels = labels,
        languages = languages,
        test_only = test_only,
        root_dir = root_dir,
        protoc_flags = protoc_flags,
    )


def go_grpc_gateway_standalone_language(configuration:str):
    return proto_language(
        language = "go",
        build_def = go_grpc_gateway_standalone_library(configuration),
        additional_provides = {"go_src": "go_srcs", "modinfo": "go_modinfo"},
    )

def go_grpc_gateway_standalone_library(configuration:str):
    def standalone_library(
            name:str, srcs:list, deps:list=[], visibility:list=None, labels:list&features&tags=[],
            test_only:bool&testonly=False, root_dir:str='', protoc_flags:list=[], additional_context:dict=None):
        """Defines a rule for a go grpc gateway library"""
        if additional_context:
            fail("additional_context is not used in this rule")
        deps += [
            CONFIG.GO_PROTO.PROTO_DEP,
            CONFIG.GO_PROTO.GRPC_DEP,
            CONFIG.GRPC_GATEWAY_PLUGIN,
            CONFIG.GRPC_GATEWAY_GO_DEP,
            CONFIG.GRPC_VALIDATE_PLUGIN,
            '//third_party/go:protoc-gen-validate-lib',
        ]
        protoc = protoc_rule(
            name = name,
            srcs = srcs,
            language = "go",
            tools = {
                # "go": [CONFIG.GO_PROTO.PLUGIN],
                # "grpc_go": [CONFIG.GO_PROTO.GRPC_PLUGIN],
                "grpc_gateway_go": [CONFIG.GRPC_GATEWAY_PLUGIN],
                "grpc_gateway_configuration": [configuration],
            },
            protoc_flags = protoc_flags,
            plugin_flags = [            
                # # Go plugin.
                # '--plugin=protoc-gen-go="`which $TOOLS_GO`"',
                # '--go_out="$OUT_DIR"',
                # '--go_opt=paths=source_relative',
                # # gRPC plugin.
                # '--go-grpc_out="$OUT_DIR"',
                # '--plugin=protoc-gen-go-grpc="`which $TOOLS_GRPC_GO`"',
                # '--go-grpc_opt=paths=source_relative,require_unimplemented_servers=false',
                # gRPC gateway plugin.
                '--plugin=protoc-gen-grpc-gateway="`which $TOOLS_GRPC_GATEWAY_GO`"',
                '--grpc-gateway_out="$OUT_DIR"',
                f'--grpc-gateway_opt=paths=source_relative,standalone=true,grpc_api_configuration=$(out_location {configuration})',
            ],
            labels = labels + _go_mapping_labels(srcs, root_dir),
            test_only = test_only,
            root_dir = root_dir,
            deps = deps,
            visibility = visibility,
            pre_build = _go_path_mapping(),
        )
        return go_library(
            name = f"_{name}#go",
            srcs = [protoc],
            deps = deps,
            test_only = test_only,
            labels = labels,
            visibility = visibility,
            import_path = _import_path(root_dir),
        )
    return standalone_library

        
def _go_path_mapping():
    """Pre-build rule to update the Go path mapping"""
    def _map_go_paths(rule_name):
        labels = get_labels(rule_name, 'proto:go-map:')
        mapping = ''
        mapping_validate = ''
        if len(labels) > 0:
            mapping = ',M' + ',M'.join(get_labels(rule_name, 'proto:go-map:')) + ':'
            # mapping = 'M' + ',M'.join(labels) + ':'
            mapping_validate = ',M' + ',M'.join(labels)

        cmd = get_command(rule_name)
        new_cmd = cmd.replace('--go_out=', f'--go_out={mapping}')
        new_cmd = new_cmd.replace('lang=go', f'lang=go{mapping_validate}')
        new_cmd = new_cmd.replace('--go-grpc_out=', f'--go-grpc_out={mapping}')
        new_cmd = new_cmd.replace('--grpc-gateway_out=', f'--grpc-gateway_out={mapping}')
        set_command(rule_name, new_cmd)
    return _map_go_paths


def _go_mapping_labels(srcs:list, root_dir:str):
    import_path = get_base_path()
    pkg_dir = import_path
    if root_dir:
        import_path = import_path.removeprefix(root_dir + "/")
        pkg_dir = pkg_dir.removeprefix(root_dir + "/")
    if CONFIG.GO.IMPORT_PATH:
        import_path = join_path(CONFIG.GO.IMPORT_PATH, import_path)
    return [f'proto:go-map: {pkg_dir}/{src}={import_path}' for src in srcs if not src.startswith(':') and not src.startswith('/')]


def _import_path(root_dir):
    pkg = package_name()
    if root_dir:
        pkg = pkg.removeprefix(root_dir + "/")

    if CONFIG.GO.IMPORT_PATH:
        return join_path(CONFIG.GO.IMPORT_PATH, pkg)
    return pkg
